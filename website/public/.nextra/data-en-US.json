{"/":{"title":"Introduction","data":{"":"Get Started · Blog · GitHub Repository\nInlang is an open source software localization solution build on top of Mozilla's Fluent that strives to make localization (translation) of software easier.[x] Collaboration on translations with non-technical team members or translators.\n[x] Machine translations.\n[-] Linting of translations (in the dashboard).\n[-] Synchronize translations (via the CLI or Copy & Paste).\n[] Over the air updates without releasing a new version of your app.\n[] Self-hostable, see this discussion.Are you missing a feature? Head over to discussion to request a new feature.","status#Status":"[x] Alpha: Stable enough to translate simple apps.\n[ ] Beta: Translate medium sized software projects which require ongoing translations.\n[ ] Release: Production ready.","community--support#Community & Support":"GitHub Discussions: feedback and questions.\nGitHub Issues: bugs you encounter using inlang.\nDiscord: contact the maintainers and hang out with the community."}},"/blog/inlang-v0-2":{"title":"Inlang v0.2","data":{"":"TODO"}},"/docs/getting-started":{"title":"Getting Started","data":{"":"By default, key will be passed to fetcher as the argument. So the following 3 expressions are equivalent:\nuseSWR('/api/user', () => fetcher('/api/user'))\nuseSWR('/api/user', url => fetcher(url))\nuseSWR('/api/user', fetcher)","multiple-arguments#Multiple Arguments":"In some scenarios, it's useful to pass multiple arguments (can be any value or object) to the fetcher function.\nFor example an authorized fetch request:\nuseSWR('/api/user', url => fetchWithToken(url, token))\nThis is incorrect. Because the identifier (also the cache key) of the data is '/api/user',\neven if token changes, SWR will still use the same key and return the wrong data.Instead, you can use an array as the key parameter, which contains multiple arguments of fetcher:\nconst { data: user } = useSWR(['/api/user', token], fetchWithToken)\nThe function fetchWithToken still accepts the same 2 arguments, but the cache key will also be associated with token now.","passing-objects#Passing Objects":"Since SWR 1.1.0, object-like keys will be serialized under the hood automatically.\nSay you have another function that fetches data with a user scope: fetchWithUser(api, user). You can do the following:\nconst { data: user } = useSWR(['/api/user', token], fetchWithToken)\n\n// ...and then pass it as an argument to another useSWR hook\nconst { data: orders } = useSWR(user ? ['/api/orders', user] : null, fetchWithUser)\nYou can directly pass an object as the key, and fetcher will receive that object too:\nconst { data: orders } = useSWR({ url: '/api/orders', args: user }, fetcher)\n\nIn older versions (< 1.1.0), SWR shallowly compares the arguments on every render, and triggers revalidation if any of them has changed."}}}